<!doctype html>
<html>
<head>


  <meta charset="utf-8">
  <link rel="shortcut icon" href="https://www.univ-amu.fr/misc/favicon.ico" type="image/vnd.microsoft.icon" />
  <meta name="MobileOptimized" content="width" />
  <title>SXP Kademilia</title>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
         
               
              <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
</head>
<body>
<style type="text/css">

    .navbar-inverse {
    
    background-color:#2c3e50 !important;
    font-size: large;
    font-weight: bold;

    
}

h1, h2, h3, p , table {
   margin : 40px;
}

h1{
  text-align: center;
  margin-top: 50px;
  color: #000047;
}

p{
  font-family: Verdana;
  font-size: 0.9;
}

footer {
      background-color: #1b212b;
      padding: 65px;
      color: white;
      font-family: Verdana;
      font-size: 1.0em;
    }

    /* Hide the carousel text when the screen is less than 600 pixels wide */
    @media (max-width: 600px) {
      .carousel-caption {
        display: none; 
      }
    }

    table
{
    border-collapse: collapse;
    text-align: center;
    margin-bottom: 10px;

}

td /* Mettre une bordure sur les td  */
{
    border: 2px solid black;
    width: 100px;

}


</style>
              <nav class="navbar navbar-inverse" style="position: fixed; top:0; width: 100%;">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>                        
      </button>
      <a class="navbar-brand" href=""></a>
    </div>
    <div class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav">
        <li><a href="description.html">Description</a></li>
        <li><a href="test.html" target="_blank">Test de robustesse</a></li>
         <li><a href="utilisation.html" target="_blank">Mode d'emploi</a></li>
        <li><a href="#footer">A propos</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li></li>
      </ul>
    </div>
  </div>
</nav>

<h1 style="margin-top: 70px;">Description du projet KADEMILIA</h1>
<div class="container-fluid" id="intro">
 <h2> INTRODUCTION : </h2>
 <p>
Kademlia(alias Kad) est un réseau de recouvrement créé pour décentraliser les autres réseaux
d'échange de fichiers Peer-to-Peer. Le protocole précise la structure du réseau Kademlia, les
communications entre les noeuds et l'échange d'information. Les noeuds communiquent grâce au
protocole UDP.
</p>
</div>


<div class="container-fluid" id="fonctionnement">
  <h2>FONCTIONNEMENT :</h2>
  <p>A l'intérieur d'un réseau existant, Kademlia crée un nouveau réseau, à l'intérieur duquel chaque
noeud est identifié par un numéro d'identification, un ID (nombre binaire à 160 bits.)
Passée une phase d'amorçage consistant à contacter un noeud du réseau puis à obtenir un ID, un
algorithme calcule la «distance » entre deux noeuds, et interroge plusieurs noeuds suivant cet
algorithme afin de trouver l'information recherchée. Cet algorithme utilise une notion de distance
entre deux noeuds, calculée grâce à une opération mathématique (OU exclusif, aussi appelée
XOR) délivrant un résultat sous forme de nombre entier : la «distance». Cette dernière n'a rien à
voir avec la situation géographique des participants, mais modélise la distance à l'intérieur de la
chaîne des ID. Il peut donc arriver qu'un noeud en Allemagne et un noeud en Australie soient
«voisins ».
Une information dans Kademlia est conservée dans des «valeurs », chaque valeur étant jointe à
une «clé ». On dit de Kademlia qu'il est un réseau < valeur,clé >.
Lors de la recherche d'une certaine clé, l'algorithme explore récursivement le réseau au cours de
différentes étapes, chaque étape s'approchant plus près de la clé recherchée, jusqu'à ce que le
noeud contacté retourne la valeur, ou que plus aucun noeud ne soit trouvé. La taille du réseau
n'influe pas énormément sur le nombre de noeuds contactés durant la recherche ; si le nombre de
participants du réseau double, alors le noeud de l'utilisateur doit demander l'information à un
seul noeud de plus.
D'autres avantages sont inhérents à une structure décentralisée, augmentant par exemple la
résistance à une attaque de déni de service. Même si toute une rangée de noeuds est submergée,
cela n'aura que des effets limités sur la disponibilité du réseau, qui «recoudra » le réseau autour
de ces trous.</p>
</div>

<div class="container-fluid" id="hachage">
  <h2>TABLE DE HACHAGE :</h2>
  <p>Une fonction de hachage est une fonction qui est « statistiquement injective » : si x != y alors
probablement h(x) != h(y) Une table de hachage est une structure où les données sont stockées
selon la valeur d’une fonction de hachage:</p>
<table>
   <tr>
       <td>0</td>
       <td>1</td>
       <td>h(x)</td>
       <td>3</td>
       <td>h(y)=h(z)</td>
       <td>h(t)</td>
       <td>6</td>
       <td>7</td>
   </tr>
   <tr>
       <td> </td>
       <td> </td>
       <td>x</td>
       <td> </td>
       <td>y,z</td>
       <td>t</td>
       <td> </td>
       <td> </td>
   </tr>
</table>
</div>

<div class="container-fluid" id="dht">
  <h2>DHT :</h2>
  <p>Une table de hachage distribuée (DHT) est une table de hachage implémentée par un ensemble
de pairs communiquant à travers un réseau. Dans une DHT, la valeur de la fonction de hachage
détermine le pair où la donnée est stockée.</p>
</div>

<div class="container-fluid" id="identificateur">
  <h2>IDENTIFICATEUR :</h2>
  <p>Un identificateur est un entier de 160 bits. <br>
A = 01111101111001010... <br>
Les identificateurs: 
<ul>
  <li>Identifient les noeuds</li>
  <li>Servent de clés</li>
</ul>
</p>
  <p>Typiquement :
<ul>
  <li>Les identificateurs des noeuds sont tirés au hasard</li>
  <li>Les clés sont les hashes SHA-1 des « vraies » clés</li>
</ul>
</p>
</div>

<div class="container-fluid" id="xor">
<h2>LA METRIQUE XOR :</h2>
  <p>distance entre id1 et id2 : d(id1,id2)= id1 <strong>XOR</strong> id2 <br>
 Exemple: si ID codé sur 3 bits: <br>
d(1,4)== d(0012,1002) <br>
= 0012 <strong>XOR</strong> 1002 <br>
=0012 <br>
= 5</p>
</div>


<div class="container-fluid" id="routage">
  <h2>ROUTAGE EN XOR :</h2>
  <h3>Connexions entre les noeuds: </h3>
  <p>
    Chaque noeud A dans Kademlia maintient une table de routage composée d’ensembles nommés
buckets. Les buckets sont classés par ordre d’éloignement selon la métrique XOR.
Un bucket regroupe k noeuds dont les distances sont comprises entre 2 i et 2 i+1. <br>
Le degré moyen d’un noeud est donc O (k*log2^bN ). <br>
Tous les noeuds du même bucket sont à la même distance du noeud A.
Chaque bucket correspond donc à un sous arbre et contient k voisins classés selon leur
ancienneté dans le système. <br>
A l’origine, Kademlia ne maintient pas des voisins séquentiels. <br>
Cependant, cette information peut être tirée directement de sa table de routage. <br>
En effet, les premiers buckets contiennent les identifiants des noeuds les plus proches selon la métrique XOR. <br>
Ces noeuds nommés sibling constituent l’ensemble des voisins séquentiels dans S/Kademlia.
  </p>
</div>

<div style="text-align: center;">
<img src="fig.png" align="middle">
<figcaption>Figure 1: Voisinage du noeud 0011. Les cercles en bleu représentent voisins sibling du
noeud0011.</figcaption>
</div>

<div class="container-fluid" id="routage">
  <h2>ROUTAGE</h2>
  <p>Lorsqu'un noeud S cherche une clé K, il recherche itérativement les K noeuds les plus proches de
K, S commence par identifier et envoyer sa requête à ses K voisins les plus proches parmi ses
buckets. Ces voisins vont répondre à leur tour en renvoyant leurs K noeuds les plus proches,
présents dans leurs tables de routage. Le noeud S met à jour sa table de routage puis renvoie sa
requête aux K nouveaux noeuds les plus proches. La même procédure se répète jusqu’à ce que le
noeud S ait contacté tous les autres noeuds renvoyés dans les réponses, et ainsi ait récupéré les K
noeuds dont l’ID est le plus proche de la clé K. Cet algorithme a pour but d'augmenter le préfixe
commun entre l'identifiant de la clé et celui des noeuds contactés à chaque saut. Le noeud qui
effectue une recherche contacte donc un à un tous les noeuds intermédiaires de la route jusqu’à
atteindre la destination. Ceux ci lui fournissent en retour une liste de contacts possibles pour le
saut suivant (Figure 2). Le nombre de sauts moyen nécessaires pour une recherche de clé sur un
alphabet de 2b chiffres est O log(2^b)N .</p>

<div style="text-align: center;">
  <img src="fig2.png" align="middle">
<figcaption>Figure 2:Exemple de route Kademlia : le noeud 0011 localise le noeud 1110</figcaption>
</div>

</div>

<div class="container-fluid" id="maintenance">
  <h2>MAINTENANCE :</h2>
  <p>la maintenance dans Kademlia est implicite. Lorsqu’un noeud reçoit un message find_node, il met
à jour le bucket approprié. Si le noeud expéditeur se trouve déjà dans ce bucket, il est déplacé en
bas de la liste. Sinon, si le bucket n’est pas plein, la nouvelle entrée est insérée. Si le bucket est
plein, le noeud A émet un PING vers le voisin le plus ancien dans ce bucket. Si ce dernier répond
au PING, il est alors déplacé en fin de liste et la nouvelle entrée est ignorée. Kademlia conserve
donc dans sa table les noeuds les plus anciens dans le réseau.</p>
</div>

<div class="container-fluid" id="info">
  <h4><a href="http://people.rennes.inria.fr/Julien.Stainer/docs-akermarrec/maymounkov-kademlia-lncs.pdf" target="_blank">For more information: </a> </h4>
</div>

<footer class="container-fluid " id="footer">
  <p>Ce projet a été revu par des étudiants en Master 1 informatique à l'université d'Aix-Marseille dans le cadre du module de Génie Logiciel:</p> 
  <p> 
  <div class="col-lg-3">
  	<ul>
  	<li>BEN JEMIA Moahemed Yassine</li>
  	<li>HAMIDI Zakaria</li>
  </ul>
  </div>
  <div class="col-lg-9">
  	<ul>
    <li>ESTAILLARD Julien</li>
  	<li>FARHAT Houssem</li>
  </ul>
  </div>
  2017-2018
</p>
  <p></p>
</footer>

    <script src="index.browser.js"></script>
</body>
</html>

